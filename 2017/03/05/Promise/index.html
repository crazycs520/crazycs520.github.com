<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Promise | crazycs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="原文地址
什么是Promise什么是PromisePromise是抽象异步处理对象以及对其进行各种操作的组件。
如果说到基于JavaScript的异步处理，我想大多数都会想到利用回调函数。
1234567//使用了回调函数的异步处理getAsync(&quot;fileA.txt&quot;, function(error, result)&amp;#123;    if(error)&amp;#123;// 取得失败时的处理">
<meta property="og:type" content="article">
<meta property="og:title" content="Promise">
<meta property="og:url" content="http://crazycs.com/2017/03/05/Promise/index.html">
<meta property="og:site_name" content="crazycs">
<meta property="og:description" content="原文地址
什么是Promise什么是PromisePromise是抽象异步处理对象以及对其进行各种操作的组件。
如果说到基于JavaScript的异步处理，我想大多数都会想到利用回调函数。
1234567//使用了回调函数的异步处理getAsync(&quot;fileA.txt&quot;, function(error, result)&amp;#123;    if(error)&amp;#123;// 取得失败时的处理">
<meta property="og:image" content="http://github.com/crazycs520/images/blob/master/3.png?raw=true">
<meta property="og:updated_time" content="2017-03-06T09:14:18.291Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Promise">
<meta name="twitter:description" content="原文地址
什么是Promise什么是PromisePromise是抽象异步处理对象以及对其进行各种操作的组件。
如果说到基于JavaScript的异步处理，我想大多数都会想到利用回调函数。
1234567//使用了回调函数的异步处理getAsync(&quot;fileA.txt&quot;, function(error, result)&amp;#123;    if(error)&amp;#123;// 取得失败时的处理">
<meta name="twitter:image" content="http://github.com/crazycs520/images/blob/master/3.png?raw=true">
  
    <link rel="alternate" href="/atom.xml" title="crazycs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">crazycs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://crazycs.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/05/Promise/" class="article-date">
  <time datetime="2017-03-05T14:55:20.000Z" itemprop="datePublished">2017-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Promise
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://liubin.org/promises-book/" target="_blank" rel="external">原文地址</a></p>
<h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><h3 id="什么是Promise-1"><a href="#什么是Promise-1" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><p>Promise是抽象异步处理对象以及对其进行各种操作的组件。</p>
<p>如果说到基于JavaScript的异步处理，我想大多数都会想到利用回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用了回调函数的异步处理</span></div><div class="line">getAsync(<span class="string">"fileA.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(error)&#123;<span class="comment">// 取得失败时的处理</span></div><div class="line">        <span class="keyword">throw</span> error;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 取得成功时的处理</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Node.js等则规定在JavaScript的回调函数的第一个参数为 <code>Error</code> 对象，这也是它的一个惯例。</p>
<p>像上面这样基于回调函数的异步处理如果统一参数使用规则的话，写法也会很明了。</p>
<p>而Promise则是把类似的异步处理对象和处理规则进行规范化， 并按照采用统一的接口来编写，而采取规定方法之外的写法都会出错。</p>
<p>下面是使用了Promise进行异步处理的一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var promise = getAsyncPromise(&quot;fileA.txt&quot;); </div><div class="line">promise.then(function(result)&#123;</div><div class="line">    // 获取文件内容成功时的处理</div><div class="line">&#125;).catch(function(error)&#123;</div><div class="line">    // 获取文件内容失败时的处理</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这和回调函数方式相比有哪些不同之处呢？ 在使用promise进行一步处理的时候，我们必须按照接口规定的方法编写处理代码。</p>
<p>也就是说，除promise对象规定的方法(这里的 <code>then</code> 或 <code>catch</code>)以外的方法都是不可以使用的， 而不会像回调函数方式那样可以自己自由的定义回调函数的参数，而必须严格遵守固定、统一的编程方式来编写代码。</p>
<p>这样，基于Promise的统一接口的做法， 就可以形成基于接口的各种各样的异步处理模式。</p>
<p>所以，promise的功能是可以将复杂的异步处理轻松地进行模式化， 这也可以说得上是使用promise的理由之一。</p>
<h3 id="Promise-简介"><a href="#Promise-简介" class="headerlink" title="Promise 简介"></a>Promise 简介</h3><p>在 <a href="http://liubin.org/promises-book/#es6-promises" target="_blank" rel="external">ES6 Promises</a> 标准中定义的API还不是很多。</p>
<p>目前大致有下面三种类型。</p>
<ol>
<li><strong>Constructor</strong></li>
</ol>
<p>Promise类似于 <code>XMLHttpRequest</code>，从构造函数 <code>Promise</code> 来创建一个新建新<code>promise</code>对象作为接口。</p>
<p>要想创建一个promise对象、可以使用<code>new</code>来调用<code>Promise</code>的构造器来进行实例化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">    // 异步处理</div><div class="line">    // 处理结束后、调用resolve 或 reject</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li><strong>Instance Method</strong></li>
</ol>
<p>对通过new生成的promise对象为了设置其值在 <strong>resolve</strong>(成功) / <strong>reject</strong>(失败)时调用的回调函数 可以使用<code>promise.then()</code> 实例方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
<ul>
<li><p>resolve(成功)时</p>
<p><code>onFulfilled</code> 会被调用</p>
</li>
<li><p>reject(失败)时</p>
<p><code>onRejected</code> 会被调用</p>
</li>
</ul>
<p><code>onFulfilled</code>、<code>onRejected</code> 两个都为可选参数。</p>
<p><code>promise.then</code> 成功和失败时都可以使用。 另外在只想对异常进行处理时可以采用 <code>promise.then(undefined, onRejected)</code> 这种方式，只指定reject时的回调函数即可。 不过这种情况下 <code>promise.catch(onRejected)</code> 应该是个更好的选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.catch(onRejected)</div></pre></td></tr></table></figure>
<ol>
<li><strong>Static Method</strong></li>
</ol>
<p>像 <code>Promise</code> 这样的全局对象还拥有一些静态方法。</p>
<p>包括 <code>Promise.all()</code> 还有 <code>Promise.resolve()</code> ,<code>Promise.race()</code>等在内，主要都是一些对Promise进行操作的辅助方法。</p>
<h4 id="Promise-workflow"><a href="#Promise-workflow" class="headerlink" title="Promise workflow"></a>Promise workflow</h4><p>先来看一看下面的示例代码。</p>
<p>promise-workflow.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//1</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            resolve(<span class="string">'Async Hello world'</span>);</div><div class="line">        &#125;, <span class="number">16</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//2</span></div><div class="line">asyncFunction().then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);    <span class="comment">// =&gt; 'Async Hello world'</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li><code>new Promise</code>构造器之后，会返回一个promise对象</li>
<li>为promise对象用设置 <code>.then</code> 调用返回值时的回调函数。</li>
</ol>
<p><code>asyncFunction</code> 这个函数会返回promise对象， 对于这个promise对象，我们调用它的 <code>then</code> 方法来设置resolve后的回调函数， <code>catch</code> 方法来设置发生错误时的回调函数。</p>
<p>该promise对象会在setTimeout之后的16ms时被resolve, 这时 <code>then</code> 的回调函数会被调用，并输出 <code>&#39;Async Hello world&#39;</code> 。</p>
<p>当然，像<code>promise.then(onFulfilled, onRejected)</code> 的方法声明一样， 如果不使用<code>catch</code> 方法只使用 <code>then</code>方法的话，如下所示的代码也能完成相同的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunction().then(function (value) &#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;, function (error) &#123;</div><div class="line">    console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h4><p>用<code>new Promise</code> 实例化的promise对象有以下三个状态。</p>
<p>​    <strong>“has-resolution” - Fulfilled</strong></p>
<p>resolve(成功)时。此时会调用 <code>onFulfilled</code></p>
<p>​    <strong>“has-rejection” - Rejected</strong></p>
<p>reject(失败)时。此时会调用 <code>onRejected</code></p>
<p>​    <strong>“unresolved” - Pending</strong></p>
<p>既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等</p>
<p>promise对象的状态，从<em>Pending</em>转换为<em>Fulfilled</em>或<em>Rejected</em>之后， 这个promise对象的状态就不会再发生任何变化。</p>
<p>也就是说，Promise与Event等不同，在<code>.then</code> 后执行的函数可以肯定地说只会被调用一次。</p>
<p>另外，<em>Fulfilled</em>和<em>Rejected</em>这两个中的任一状态都可以表示为<strong>Settled</strong>(不变的)。</p>
<p>​    <strong>Settled</strong></p>
<p>resolve(成功) 或 reject(失败)。</p>
<p>当promise的对象状态发生变化时，用<code>.then</code> 来定义只会被调用一次的函数。</p>
<h3 id="编写Promise代码"><a href="#编写Promise代码" class="headerlink" title="编写Promise代码"></a>编写Promise代码</h3><h4 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a>创建promise对象</h4><p>流程如下所示:</p>
<ol>
<li><code>new Promise(fn)</code> 返回一个promise对象</li>
<li>在<code>fn</code> 中指定异步等处理<ul>
<li>处理结果正常的话，调用<code>resolve(处理结果值)</code></li>
<li>处理结果错误的话，调用<code>reject(Error对象)</code></li>
</ul>
</li>
</ol>
<p><strong>创建XHR的promise对象</strong></p>
<p>首先，创建一个用Promise把XHR处理包装起来的名为 <code>getURL</code> 的函数。</p>
<p><em>xhr-promise.js</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function getURL(URL) &#123;</div><div class="line">    return new Promise(function (resolve, reject) &#123;</div><div class="line">        var req = new XMLHttpRequest();</div><div class="line">        req.open(&apos;GET&apos;, URL, true);</div><div class="line">        req.onload = function () &#123;</div><div class="line">            if (req.status === 200) &#123;</div><div class="line">                resolve(req.responseText);</div><div class="line">            &#125; else &#123;</div><div class="line">                reject(new Error(req.statusText));</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        req.onerror = function () &#123;</div><div class="line">            reject(new Error(req.statusText));</div><div class="line">        &#125;;</div><div class="line">        req.send();</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">// 运行示例</div><div class="line">var URL = &quot;http://httpbin.org/get&quot;;</div><div class="line">getURL(URL).then(function onFulfilled(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;).catch(function onRejected(error)&#123;</div><div class="line">    console.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>getURL</code> 只有在通过XHR取得结果状态为200时才会调用 <code>resolve</code> - 也就是只有数据取得成功时，而其他情况（取得失败）时则会调用 <code>reject</code> 方法。</p>
<p><code>resolve(req.responseText)</code> 在response的内容中加入了参数。 resolve方法的参数并没有特别的规则，基本上把要传给回调函数参数放进去就可以了。 ( <code>then</code> 方法可以接收到这个参数值)</p>
<p>熟悉Node.js的人，经常会在写回调函数时将 <code>callback(error, response)</code> 的第一个参数设为error对象，而在Promise中resolve/reject则担当了这个职责（处理正常和异常的情况），所以 在resolve方法中只传一个response参数是没有问题的。</p>
<p>XHR中 <code>onerror</code> 事件被触发的时候就是发生错误时，所以理所当然调用<code>reject</code>。 这里我们重点来看一下传给<code>reject</code>的值。</p>
<p>发生错误时要像这样 <code>reject(new Error(req.statusText));</code> ，创建一个Error对象后再将具体的值传进去。 传给<code>reject</code> 的参数也没有什么特殊的限制，一般只要是Error对象（或者继承自Error对象）就可以。</p>
<p>传给<code>reject</code> 的参数，其中一般是包含了reject原因的Error对象。 本次因为状态值不等于200而被reject，所以<code>reject</code> 中放入的是statusText。 （这个参数的值可以被 <code>then</code> 方法的第二个参数或者 <code>catch</code> 方法中使用）</p>
<h4 id="编写promise对象处理方法"><a href="#编写promise对象处理方法" class="headerlink" title="编写promise对象处理方法"></a>编写promise对象处理方法</h4><p>我们在实际中使用一下刚才创建的返回promise对象的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getURL(&quot;http://example.com/&quot;); // =&gt; 返回promise对象</div></pre></td></tr></table></figure>
<p>如<em>Promises Overview</em>中做的简单介绍一样，promise对象拥有几个实例方法， 我们使用这些实例方法来为promise对象创建依赖于promise的具体状态、并且只会被执行一次的回调函数。</p>
<p>为promise对象添加处理方法主要有以下两种</p>
<ul>
<li>promise对象被 <strong>resolve</strong> 时的处理(onFulfilled)</li>
<li>promise对象被 <strong>reject</strong> 时的处理(onRejected)</li>
</ul>
<p>首先，我们来尝试一下为 <code>getURL</code> 通信成功并取到值时添加的处理函数。</p>
<p>此时所谓的 <em>通信成功</em> ， 指的就是在被resolve后， <em>promise对象变为FulFilled状态</em> 。</p>
<p>被<strong>resolve</strong>后的处理，可以在<a href="http://liubin.org/promises-book/#promise.then" target="_blank" rel="external"><code>.then</code></a> 方法中传入想要调用的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var URL = &quot;http://httpbin.org/get&quot;;</div><div class="line">getURL(URL).then(function onFulfilled(value)&#123; </div><div class="line">    console.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="http://liubin.org/promises-book/#xhr-promise.js" target="_blank" rel="external">getURL函数</a> 中的 <code>resolve(req.responseText);</code> 会将promise对象变为resolve（Fulfilled）状态， 同时使用其值调用 <code>onFulfilled</code>函数。</p>
<p>不过目前我们还没有对其中可能发生的错误做任何处理， 接下来，我们就来为 <code>getURL</code> 函数添加发生错误时的异常处理。</p>
<p>此时 <em>发生错误</em> ， 指的也就是reject后 <em>promise对象变为Rejected状态</em> 。</p>
<p>被<strong>reject</strong>后的处理，可以在<a href="http://liubin.org/promises-book/#promise.then" target="_blank" rel="external"><code>.then</code> 的第二个参数</a> 或者是在 <a href="http://liubin.org/promises-book/#promise.catch" target="_blank" rel="external"><code>.catch</code></a> 方法中设置想要调用的函数。</p>
<p>把下面reject时的处理加入到刚才的代码，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var URL = &quot;http://httpbin.org/status/500&quot;; 		//1</div><div class="line">getURL(URL).then(function onFulfilled(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;).catch(function onRejected(error)&#123; 			//2</div><div class="line">    console.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>服务端返回的状态码为500</li>
<li>为了方便理解函数被命名为 <code>onRejected</code></li>
</ol>
<p>在<code>getURL</code> 的处理中发生任何异常，或者被明确reject的情况下， 该异常原因（Error对象）会作为 <a href="http://liubin.org/promises-book/#promise.catch" target="_blank" rel="external"><code>.catch</code></a> 方法的参数被调用。</p>
<p>其实 <a href="http://liubin.org/promises-book/#promise.catch" target="_blank" rel="external"><code>.catch</code></a>只是 <code>promise.then(undefined, onRejected)</code> 的别名而已， 如下代码也可以完成同样的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getURL(URL).then(onFulfilled, onRejected);	//1</div></pre></td></tr></table></figure>
<ol>
<li>onFulfilled, onRejected 是和刚才相同的函数</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>用 <code>new Promise</code> 方法创建promise对象</li>
<li>用<a href="http://liubin.org/promises-book/#promise.then" target="_blank" rel="external"><code>.then</code></a> 或 <a href="http://liubin.org/promises-book/#promise.catch" target="_blank" rel="external"><code>.catch</code></a> 添加promise对象的处理函数</li>
</ul>
<p>实际上即使使用回调方式的写法也能完成上面同样的工作，而使用Promise方式的话有什么优点么？在本小节中我们没有讲到两者的对比及Promise的优点。在接下来的章节中，我们将会对Promise优点之一，即<strong>错误处理机制</strong>进行介绍，以及和传统的回调方式的对比。</p>
<h2 id="实战Promise"><a href="#实战Promise" class="headerlink" title="实战Promise"></a>实战Promise</h2><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><h4 id="new-Promise的快捷方式"><a href="#new-Promise的快捷方式" class="headerlink" title="new Promise的快捷方式"></a>new Promise的快捷方式</h4><p>静态方法<a href="http://liubin.org/promises-book/#Promise.resolve" target="_blank" rel="external"><code>Promise.resolve(value)</code></a> 可以认为是 <code>new Promise()</code> 方法的快捷方式。</p>
<p>比如 <code>Promise.resolve(42);</code> 可以认为是以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Promise(function(resolve)&#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这段代码中的 <code>resolve(42);</code> 会让这个promise对象立即进入确定（即resolved）状态，并将 <code>42</code> 传递给后面then里所指定的 <code>onFulfilled</code> 函数。</p>
<p>方法 <code>Promise.resolve(value);</code> 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 <code>.then</code> 调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.resolve(42).then(function(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="http://liubin.org/promises-book/#Promise.resolve" target="_blank" rel="external">Promise.resolve</a>作为 <code>new Promise()</code> 的快捷方式，在进行promise对象的初始化或者编写测试代码的时候都非常方便。</p>
<h4 id="Thenable"><a href="#Thenable" class="headerlink" title="Thenable"></a>Thenable</h4><p><code>Promise.resolve</code> 方法另一个作用就是将 <a href="http://liubin.org/promises-book/#Thenable" target="_blank" rel="external">thenable</a> 对象转换为promise对象。</p>
<p><a href="http://liubin.org/promises-book/#es6-promises" target="_blank" rel="external">ES6 Promises</a>里提到了<a href="http://liubin.org/promises-book/#Thenable" target="_blank" rel="external">Thenable</a>这个概念，简单来说它就是一个非常类似promise的东西。</p>
<p>就像我们有时称具有 <code>.length</code> 方法的非数组对象为Array like一样，thenable指的是一个具有 <code>.then</code> 方法的对象。</p>
<p>这种将thenable对象转换为promise对象的机制要求thenable对象所拥有的 <code>then</code> 方法应该和Promise所拥有的 <code>then</code> 方法具有同样的功能和处理过程，在将thenable对象转换为promise对象的时候，还会巧妙的利用thenable对象原来具有的 <code>then</code> 方法。</p>
<p>到底什么样的对象能算是thenable的呢，最简单的例子就是 <a href="https://api.jquery.com/jQuery.ajax/" target="_blank" rel="external">jQuery.ajax()</a>，它的返回值就是thenable的。</p>
<p>因为<code>jQuery.ajax()</code> 的返回值是 <a href="http://api.jquery.com/jQuery.ajax/#jqXHR" target="_blank" rel="external">jqXHR Object</a> 对象，这个对象具有 <code>.then</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$.ajax(<span class="string">'/json/comment.json'</span>);<span class="comment">// =&gt; 拥有 `.then` 方法的对象</span></div></pre></td></tr></table></figure>
<p>这个thenable的对象可以使用 <code>Promise.resolve</code> 来转换为一个promise对象。</p>
<p>变成了promise对象的话，就能直接使用 <code>then</code> 或者 <code>catch</code> 等这些在 <a href="http://liubin.org/promises-book/#es6-promises" target="_blank" rel="external">ES6 Promises</a>里定义的方法了。</p>
<p>将thenable对象转换promise对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var promise = Promise.resolve($.ajax(&apos;/json/comment.json&apos;));// =&gt; promise对象</div><div class="line">promise.then(function(value)&#123;</div><div class="line">   console.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>jQuery和thenable</p>
<p><a href="https://api.jquery.com/jQuery.ajax/" target="_blank" rel="external">jQuery.ajax()</a>的返回值是一个具有 <code>.then</code> 方法的 <a href="http://api.jquery.com/jQuery.ajax/#jqXHR" target="_blank" rel="external">jqXHR Object</a>对象，这个对象继承了来自 <a href="http://api.jquery.com/category/deferred-object/" target="_blank" rel="external">Deferred Object</a> 的方法和属性。</p>
<p>但是Deferred Object并没有遵循<a href="http://liubin.org/promises-book/#promises-aplus" target="_blank" rel="external">Promises/A+</a>或<a href="http://liubin.org/promises-book/#es6-promises" target="_blank" rel="external">ES6 Promises</a>标准，所以即使看上去这个对象转换成了一个promise对象，但是会出现缺失部分信息的问题。</p>
<p>这个问题的根源在于jQuery的 <a href="http://api.jquery.com/category/deferred-object/" target="_blank" rel="external">Deferred Object</a> 的 <code>then</code> 方法机制与promise不同。</p>
<p>所以我们应该注意，即使一个对象具有 <code>.then</code> 方法，也不一定就能作为ES6 Promises对象使用。</p>
<p><code>Promise.resolve</code> 只使用了共通的方法 <code>then</code> ，提供了在不同的类库之间进行promise对象互相转换的功能。</p>
<p>这种转换为thenable的功能在之前是通过使用 <code>Promise.cast</code> 来完成的，从它的名字我们也不难想象它的功能是什么。</p>
<p>除了在编写使用Promise的类库等软件时需要对Thenable有所了解之外，通常作为end-user使用的时候，我们可能不会用到此功能。</p>
<p>简单总结一下 <code>Promise.resolve</code> 方法的话，可以认为它的作用就是将传递给它的参数填充（Fulfilled）到promise对象后并返回这个promise对象。</p>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p><a href="http://liubin.org/promises-book/#Promise.reject" target="_blank" rel="external"><code>Promise.reject(error)</code></a>是和 <a href="http://liubin.org/promises-book/#Promise.resolve" target="_blank" rel="external"><code>Promise.resolve(value)</code></a> 类似的静态方法，是 <code>new Promise()</code> 方法的快捷方式。</p>
<p>比如 <code>Promise.reject(new Error(&quot;出错了&quot;))</code> 就是下面代码的语法糖形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Promise(function(resolve,reject)&#123;</div><div class="line">    reject(new Error(&quot;出错了&quot;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码的功能是调用该promise对象通过then指定的 <code>onRejected</code> 函数，并将错误（Error）对象传递给这个 <code>onRejected</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.reject(new Error(&quot;BOOM!&quot;)).catch(function(error)&#123;</div><div class="line">    console.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>它和<a href="http://liubin.org/promises-book/#Promise.resolve" target="_blank" rel="external"><code>Promise.resolve(value)</code></a> 的不同之处在于promise内调用的函数是reject而不是resolve，这在编写测试代码或者进行debug时，说不定会用得上。</p>
<h3 id="专栏-Promise只能进行异步操作？"><a href="#专栏-Promise只能进行异步操作？" class="headerlink" title="专栏: Promise只能进行异步操作？"></a>专栏: Promise只能进行异步操作？</h3><p>在使用<a href="http://liubin.org/promises-book/#Promise.resolve" target="_blank" rel="external"><code>Promise.resolve(value)</code></a> 等方法的时候，如果promise对象立刻就能进入resolve状态的话，那么你是不是觉得 <code>.then</code> 里面指定的方法就是同步调用的呢？</p>
<p>实际上， <code>.then</code> 中指定的方法调用是异步进行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function (resolve)&#123;</div><div class="line">    console.log(&quot;inner promise&quot;); // 1</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">promise.then(function(value)&#123;</div><div class="line">    console.log(value); // 3</div><div class="line">&#125;);</div><div class="line">console.log(&quot;outer promise&quot;); // 2</div></pre></td></tr></table></figure>
<p>执行上面的代码会输出下面的log，从这些log我们清楚地知道了上面代码的执行顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inner promise // 1</div><div class="line">outer promise // 2</div><div class="line">42            // 3</div></pre></td></tr></table></figure>
<p>由于JavaScript代码会按照文件的从上到下的顺序执行，所以最开始 <code>&lt;1&gt;</code> 会执行，然后是 <code>resolve(42);</code> 被执行。这时候 <code>promise</code> 对象的已经变为确定状态，FulFilled被设置为了 <code>42</code> 。</p>
<p>下面的代码 <code>promise.then</code> 注册了 <code>&lt;3&gt;</code> 这个回调函数，这是本专栏的焦点问题。</p>
<p>由于 <code>promise.then</code> 执行的时候promise对象已经是确定状态，从程序上说对回调函数进行同步调用也是行得通的。</p>
<p>但是即使在调用 <code>promise.then</code> 注册回调函数的时候promise对象已经是确定的状态，Promise也会以异步的方式调用该回调函数，这是在Promise设计上的规定方针。</p>
<p>因此 <code>&lt;2&gt;</code> 会最先被调用，最后才会调用回调函数 <code>&lt;3&gt;</code> 。</p>
<p>为什么要对明明可以以同步方式进行调用的函数，非要使用异步的调用方式呢？</p>
<h4 id="同步调用和异步调用同时存在导致的混乱"><a href="#同步调用和异步调用同时存在导致的混乱" class="headerlink" title="同步调用和异步调用同时存在导致的混乱"></a>同步调用和异步调用同时存在导致的混乱</h4><p>其实在Promise之外也存在这个问题，这里我们以一般的使用情况来考虑此问题。</p>
<p>这个问题的本质是接收回调函数的函数，会根据具体的执行情况，可以选择是以同步还是异步的方式对回调函数进行调用。</p>
<p>下面我们以 <code>onReady(fn)</code> 为例进行说明，这个函数会接收一个回调函数进行处理。</p>
<p>mixed-onready.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function onReady(fn) &#123;</div><div class="line">    var readyState = document.readyState;</div><div class="line">    if (readyState === &apos;interactive&apos; || readyState === &apos;complete&apos;) &#123;</div><div class="line">        fn();</div><div class="line">    &#125; else &#123;</div><div class="line">        window.addEventListener(&apos;DOMContentLoaded&apos;, fn);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">onReady(function () &#123;</div><div class="line">    console.log(&apos;DOM fully loaded and parsed&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;==Starting==&apos;);</div></pre></td></tr></table></figure>
<p><a href="http://liubin.org/promises-book/#mixed-onready.js" target="_blank" rel="external">mixed-onready.js</a>会根据执行时DOM是否已经装载完毕来决定是对回调函数进行同步调用还是异步调用。</p>
<p>如果在调用onReady之前DOM已经载入的话</p>
<p>对回调函数进行同步调用</p>
<p>如果在调用onReady之前DOM还没有载入的话</p>
<p>通过注册 <code>DOMContentLoaded</code> 事件监听器来对回调函数进行异步调用</p>
<p>因此，如果这段代码在源文件中出现的位置不同，在控制台上打印的log消息顺序也会不同。</p>
<p>为了解决这个问题，我们可以选择统一使用异步调用的方式。</p>
<p>async-onready.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function onReady(fn) &#123;</div><div class="line">    var readyState = document.readyState;</div><div class="line">    if (readyState === &apos;interactive&apos; || readyState === &apos;complete&apos;) &#123;</div><div class="line">        setTimeout(fn, 0);</div><div class="line">    &#125; else &#123;</div><div class="line">        window.addEventListener(&apos;DOMContentLoaded&apos;, fn);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">onReady(function () &#123;</div><div class="line">    console.log(&apos;DOM fully loaded and parsed&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;==Starting==&apos;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">绝对不能对异步回调函数（即使在数据已经就绪）进行同步调用。</div><div class="line"></div><div class="line">如果对异步回调函数进行同步调用的话，处理顺序可能会与预期不符，可能带来意料之外的后果。</div><div class="line"></div><div class="line">对异步回调函数进行同步调用，还可能导致栈溢出或异常处理错乱等问题。</div><div class="line"></div><div class="line">如果想在将来某时刻调用异步回调函数的话，可以使用 setTimeout 等异步API。</div><div class="line">Effective JavaScript</div><div class="line">— David Herman</div></pre></td></tr></table></figure>
<p>前面我们看到的 <code>promise.then</code> 也属于此类，为了避免上述中同时使用同步、异步调用可能引起的混乱问题，Promise在规范上规定 <strong>Promise只能使用异步调用方式</strong> 。</p>
<p>最后，如果将上面的 <code>onReady</code> 函数用Promise重写的话，代码如下面所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function onReadyPromise() &#123;</div><div class="line">    return new Promise(function (resolve, reject) &#123;</div><div class="line">        var readyState = document.readyState;</div><div class="line">        if (readyState === &apos;interactive&apos; || readyState === &apos;complete&apos;) &#123;</div><div class="line">            resolve();</div><div class="line">        &#125; else &#123;</div><div class="line">            window.addEventListener(&apos;DOMContentLoaded&apos;, resolve);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">onReadyPromise().then(function () &#123;</div><div class="line">    console.log(&apos;DOM fully loaded and parsed&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;==Starting==&apos;);</div></pre></td></tr></table></figure>
<p>由于Promise保证了每次调用都是以异步方式进行的，所以我们在实际编码中不需要调用 <code>setTimeout</code> 来自己实现异步调用。</p>
<h3 id="Promise-then"><a href="#Promise-then" class="headerlink" title="Promise#then"></a>Promise#then</h3><p>在前面的章节里我们对Promise基本的实例方法 <code>then</code> 和 <code>catch</code> 的使用方法进行了说明。</p>
<p>这其中，我想大家已经认识了 <code>.then().catch()</code> 这种链式方法的写法了，其实在Promise里可以将任意个方法连在一起作为一个方法链（method chain）。</p>
<p>promise可以写成方法链的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">aPromise.then(function taskA(value)&#123;</div><div class="line">// task A</div><div class="line">&#125;).then(function taskB(vaue)&#123;</div><div class="line">// task B</div><div class="line">&#125;).catch(function onRejected(error)&#123;</div><div class="line">    console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果把在 <code>then</code> 中注册的每个回调函数称为task的话，那么我们就可以通过Promise方法链方式来编写能以taskA → task B 这种流程进行处理的逻辑了。</p>
<p>Promise方法链这种叫法有点长（其实是在日语里有点长，中文还可以 –译者注），因此后面我们会简化为 <a href="http://liubin.org/promises-book/#promise-chain" target="_blank" rel="external">promise chain</a> 这种叫法。</p>
<p>Promise之所以适合编写异步处理较多的应用，promise chain可以算得上是其中的一个原因吧。</p>
<p>在本小节，我们将主要针对使用 <code>then</code> 的promise chain的行为和流程进行学习。</p>
<h4 id="Promise-chain"><a href="#Promise-chain" class="headerlink" title="Promise chain"></a>Promise chain</h4><p>在第一章 <a href="http://liubin.org/promises-book/#promise-chain" target="_blank" rel="external">promise chain</a> 里我们看到了一个很简单的 then → catch 的例子，如果我们将方法链的长度变得更长的话，那在每个promise对象中注册的onFulfilled和onRejected将会怎样执行呢？</p>
<p>注：promise chain - 即方法链越短越好。 在这个例子里我们是为了方便说明才选择了较长的方法链。</p>
<p>我们先来看看下面这样的promise chain。</p>
<p>promise-then-catch-flow.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function taskA() &#123;</div><div class="line">    console.log(&quot;Task A&quot;);</div><div class="line">&#125;</div><div class="line">function taskB() &#123;</div><div class="line">    console.log(&quot;Task B&quot;);</div><div class="line">&#125;</div><div class="line">function onRejected(error) &#123;</div><div class="line">    console.log(&quot;Catch Error: A or B&quot;, error);</div><div class="line">&#125;</div><div class="line">function finalTask() &#123;</div><div class="line">    console.log(&quot;Final Task&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var promise = Promise.resolve();</div><div class="line">promise</div><div class="line">    .then(taskA)</div><div class="line">    .then(taskB)</div><div class="line">    .catch(onRejected)</div><div class="line">    .then(finalTask);</div></pre></td></tr></table></figure>
<p>上面代码中的promise chain的执行流程</p>
<p><img src="http://github.com/crazycs520/images/blob/master/3.png?raw=true" alt=""></p>
<p>在 <a href="http://liubin.org/promises-book/#promise-then-catch-flow.js" target="_blank" rel="external">上述代码</a> 中，我们没有为 <code>then</code> 方法指定第二个参数(onRejected)，也可以像下面这样来理解。</p>
<ul>
<li><p><code>then</code></p>
<p>注册onFulfilled时的回调函数</p>
</li>
<li><p><code>catch</code></p>
<p>注册onRejected时的回调函数</p>
</li>
</ul>
<p>再看一下 <a href="http://liubin.org/promises-book/#promise-then-catch-flow.png" target="_blank" rel="external">上面的流程图</a> 的话，我们会发现 <em>Task A</em> 和 <em>Task B</em> 都有指向 <em>onRejected</em> 的线出来。</p>
<p>这些线的意思是在 <em>Task A</em> 或 <em>Task B</em> 的处理中，在下面的情况下就会调用 <em>onRejected</em> 方法。</p>
<ul>
<li>发生异常的时候</li>
<li>返回了一个Rejected状态的promise对象</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>使用<code>promise.then(onFulfilled, onRejected)</code> 的话<ul>
<li>在 <code>onFulfilled</code> 中发生异常的话，在 <code>onRejected</code> 中是捕获不到这个异常的。</li>
</ul>
</li>
<li>在 <code>promise.then(onFulfilled).catch(onRejected)</code> 的情况下<ul>
<li><code>then</code> 中产生的异常能在 <code>.catch</code> 中捕获</li>
</ul>
</li>
<li><a href="http://liubin.org/promises-book/#promise.then" target="_blank" rel="external"><code>.then</code></a> 和 <a href="http://liubin.org/promises-book/#promise.catch" target="_blank" rel="external"><code>.catch</code></a> 在本质上是没有区别的<ul>
<li>需要分场合使用。</li>
</ul>
</li>
</ol>
<h2 id="Promise-测试"><a href="#Promise-测试" class="headerlink" title="Promise 测试"></a>Promise 测试</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://crazycs.com/2017/03/05/Promise/" data-id="cizxzbgou0002rscfnb7goq8s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/03/06/Session/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Session
        
      </div>
    </a>
  
  
    <a href="/2017/03/05/MongoDB/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MongoDB</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js简介/">Node.js简介</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/Node-js简介/" style="font-size: 10px;">Node.js简介</a> <a href="/tags/express/" style="font-size: 10px;">express</a> <a href="/tags/nodejs/" style="font-size: 20px;">nodejs</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/06/Session/">Session</a>
          </li>
        
          <li>
            <a href="/2017/03/05/Promise/">Promise</a>
          </li>
        
          <li>
            <a href="/2017/03/05/MongoDB/">MongoDB</a>
          </li>
        
          <li>
            <a href="/2017/03/04/blog/">github+hexo搭建博客笔记</a>
          </li>
        
          <li>
            <a href="/2017/03/04/express/">express</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 crazycs<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>